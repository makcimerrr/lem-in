package main

import (
	"fmt"
	"log"
	"package/mypackage"
	"strconv"
	"strings"
)

type Room struct {
	Name     string
	Adjacent []string
}

var (
	ant   string
	start string
	end   string
	links []string
	rooms []string
)

func main() {
	ant, start, end, rooms, links = mypackage.Checktxt() // Appel de la fonction pour obtenir les donnée

	ants, err := strconv.Atoi(ant)

	if ants != 1 {
		fmt.Println("\tAnts :", ant)
	} else {
		fmt.Println("\tAnt :", ant)
	}

	if err != nil {
		log.Println("Error")
	}

	// Construire la carte des pièces adjacentes
	roomsMap := mypackage.BuildRoomMap(rooms, links)

	// Trouver et afficher les chemins uniques les plus courts
	findAndPrintUniquePaths(roomsMap, start, end)
}

func findAndPrintUniquePaths(roomsMap map[string]mypackage.Room, start, end string) {
	uniquePaths := findUniquePaths(roomsMap, start, end)
	printPaths(uniquePaths)
}

func findUniquePaths(roomsMap map[string]mypackage.Room, start, end string) [][]string {
	uniquePaths := [][]string{}
	currentPath := []string{start}

	findPaths(roomsMap, start, end, currentPath, &uniquePaths, map[string]bool{})

	uniquePaths = filterUniquePaths(uniquePaths)

	return uniquePaths
}

func findPaths(roomsMap map[string]mypackage.Room, currentRoom, endRoom string, currentPath []string, uniquePaths *[][]string, visited map[string]bool) {
	if currentRoom == endRoom {
		// La pièce de fin a été atteinte, ajoute le chemin à la liste des chemins uniques
		*uniquePaths = append(*uniquePaths, append([]string{}, currentPath...))
		return
	}

	visited[currentRoom] = true

	for _, nextRoom := range roomsMap[currentRoom].Adjacent {
		if !visited[nextRoom] && !contains(currentPath, nextRoom) {
			// Évite les boucles infinies en vérifiant si la pièce n'a pas déjà été visitée
			newPath := append(currentPath, nextRoom)
			findPaths(roomsMap, nextRoom, endRoom, newPath, uniquePaths, visited)
		}
	}

	delete(visited, currentRoom)
}

func contains(path []string, room string) bool {
	for _, r := range path {
		if r == room {
			return true
		}
	}
	return false
}

func filterUniquePaths(paths [][]string) [][]string {
	uniquePaths := [][]string{}
	visitedRooms := map[string]bool{}

	for _, path := range paths {
		isUnique := true
		for _, room := range path[1 : len(path)-1] { // Évite les pièces de départ et d'arrivée
			if visitedRooms[room] {
				isUnique = false
				break
			}
		}

		if isUnique {
			uniquePaths = append(uniquePaths, path)
			for _, room := range path[1 : len(path)-1] { // Évite les pièces de départ et d'arrivée
				visitedRooms[room] = true
			}
		}
	}

	return uniquePaths
}

func printPaths(paths [][]string) {
	for _, path := range paths {
		fmt.Println(strings.Join(path, " "))
	}
}
